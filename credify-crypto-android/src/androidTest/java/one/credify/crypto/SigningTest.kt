package one.credify.crypto

import androidx.test.ext.junit.runners.AndroidJUnit4
import junit.framework.Assert.*
import org.junit.Test
import org.junit.runner.RunWith
import java.util.*

@RunWith(AndroidJUnit4::class)
class SigningTest {
    private val mPassword = "Abc@123"
    private val mMessage = "message to sign"

    @Test
    fun generateKeyTest() {
        val key = KeyCreator().createSigningKey()

        assertNotNull(key.privateKeyAsPKCS8)
        assertNotNull(key.privateKeyAsPKCS8)
    }

    @Test
    fun encryptPrivateKeyTest() {
        val key = KeyCreator().createSigningKey()

        val encryptPrivateKey = key.exportPrivateKey(mPassword)

        assertNotNull(encryptPrivateKey)
    }

    @Test
    fun generateAndImportKeyTest() {
        val key = KeyCreator().createSigningKey()
        val privateKeyPem = key.privateKeyAsPKCS8
        val publicKeyPem = key.publicKeyAsPKSC8

        val importKey = KeyCreator()
            .setPrivateKey(privateKeyPem!!)
            .setPublicKey(publicKeyPem!!)
            .createSigningKey()

        assertEquals(privateKeyPem, importKey.privateKeyAsPKCS8)
        assertEquals(publicKeyPem, importKey.publicKeyAsPKSC8)
    }

    @Test
    fun encryptAndDecryptPrivateKeyWithPasswordTest() {
        val key = KeyCreator().createSigningKey()
        val keyPem = key.privateKeyAsPKCS8

        // Decrypt
        val encryptedPrivateKey = key.exportPrivateKey(mPassword)
        assertNotNull(encryptedPrivateKey)
        assertNotNull(keyPem)

        // Decrypt the encrypted private key
        val decryptedKey = KeyCreator()
            .setPrivateKey(encryptedPrivateKey)
            .setPassword(mPassword)
            .createSigningKey()

        assertNotNull(decryptedKey)
        assertEquals(keyPem, decryptedKey.privateKeyAsPKCS8)

        // Null because we only input the private key
        assertNull(decryptedKey.publicKeyAsPKSC8)
    }

    @Test
    fun signAndVerifyBase64UrlTest() {
        val key = KeyCreator().createSigningKey()
        val message = mMessage.toByteArray(charset = Charsets.UTF_8)

        // Encrypt
        val signedMessage = key.signAsBase64(message, Base64Option.URL)

        // Decrypt
        val result = key.verifyBase64(signedMessage, message, Base64Option.URL)

        assertEquals(result, true)
    }

    @Test
    fun signAndVerifyBase64DefaultTest() {
        val key = KeyCreator().createSigningKey()
        val message = mMessage.toByteArray(charset = Charsets.UTF_8)

        // Encrypt
        val signedMessage = key.signAsBase64(message, Base64Option.DEFAULT)

        // Decrypt
        val result = key.verifyBase64(signedMessage, message, Base64Option.DEFAULT)

        assertEquals(result, true)
    }

    @Test
    fun listStringToStringTest() {
        val result = "fun private public test Kotlin"
        val list = listOf("fun", "private", "public", "test", "Kotlin")

        val listToString = list.joinToString(" ")

        assertEquals(result, listToString)
    }

    @Test
    fun generateApprovalTokenTest() {
        val key = KeyCreator().createSigningKey()
        val id = UUID.randomUUID().toString()
        val clientId = UUID.randomUUID().toString()
        val scopeList = listOf("profile", "email", "address")
        val offerCode = "tiki-code"

        val approvalToken = key.generateApprovalToken(id, clientId, scopeList, offerCode)

        assertNotNull(approvalToken)
    }

    @Test
    fun generateRequestTokenTest() {
        val signingKey = KeyCreator().createSigningKey()
        val encryptionKey = KeyCreator().createEncryptionKey()
        val clientId = UUID.randomUUID().toString()
        val scopeList = listOf("profile", "email", "address")
        val offerCode = "tiki-code"

        val requestToken = signingKey.generateRequestToken(
            clientId,
            encryptionKey.publicKeyAsPKSC8!!,
            scopeList,
            offerCode
        )

        assertNotNull(requestToken)
    }

    @Test
    fun generateIdentityTokenTest() {
        val signingKey = KeyCreator().createSigningKey()
        val entityId = UUID.randomUUID().toString()
        val source = "PASSPORT"
        val hash = CryptoHelper.hashAsBase64(source, Base64Option.URL) // Just for test

        val identityToken = signingKey.generateIdentityToken(
            entityId = entityId,
            source = source,
            hash = hash
        )

        assertNotNull(identityToken)
    }

    @Test
    fun decryptKey() {
        // This key is generated by the server side
        val signingEncryptedKeyPem = "-----BEGIN ENCRYPTED PRIVATE KEY-----\n" +
                "MIGmMGIGCSqGSIb3DQEFDTBVMDQGCSqGSIb3DQEFDDAnBBATwwiF7tXyCCeBJ+Vz\n" +
                "HRX5AgInEAIBIDAMBggqhkiG9w0CCQUAMB0GCWCGSAFlAwQBKgQQ2xMbrTcKVRrc\n" +
                "NTJoawss6ARAG3Nvwe+7GxIZAzcGAcV/ciEl5HagIdjbkkfRqidCh/4ouSAf1CtR\n" +
                "KwVWu/MNu7BWZfbq6VkdX/oji0ZrR7UqIg==\n" +
                "-----END ENCRYPTED PRIVATE KEY-----"

        val password = "123456aA@"
        val signing = KeyCreator()
            .setPrivateKey(signingEncryptedKeyPem)
            .setPassword(password)
            .createSigningKey()

        assertNotNull(signing)
    }
}